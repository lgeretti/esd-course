\section{Introduction}

\begin{frame}
\frametitle{Introduction}
\framesubtitle{How do C and C++ differ?}

\begin{block}{C++ is an {\em object-oriented} language}
\begin{itemize}
\item C++ is fundamentally a superset of C that introduces the concepts of {\em classes} and their {\em objects}
\item C++ allows better organization and maintenance of your code
\end{itemize}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Introduction}
\framesubtitle{Class versus object}


\begin{block}{What is the difference?}
\begin{itemize}
\item A class is a model/template of a entity that has a manipulable state
\item An object is an instance of a class
\end{itemize}
\end{block}
\pause
\begin{block}{An example: Matrix class}
Its model may include:
\begin{itemize}
\item Data {\em fields} that hold the state: e.g., the (multi-dimensional) array of the values
\item {\em Methods} operating on such fields or external arguments: e.g., the method that computes the inverse
\item {\em Operators} : e.g., vector product between two matrices
\end{itemize}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Introduction}
\framesubtitle{What is object-oriented design?}

\begin{block}{It is based on three concepts}
\begin{itemize}
\item Encapsulation: you keep data and functions related to a concept within one class, possibly hiding implementation details; this improves clarity
\item Inheritance: you can create subclasses, inheriting some features of the parent class; this saves development time by reducing duplication
\item Polymorphism: on runtime, you can pass different implementations of an object; this allows to reason in terms of interfaces rather than implementations
\end{itemize}
Our component-based design makes heavy use of polymorphism.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Introduction}
\framesubtitle{Lecture tutorial and references}

\begin{block}{How to follow the steps of this lecture}
Clone the following repository and start from the beginning:
\url{git@bitbucket.org:uniud_esd/cpp_tutorial.git}
\medskip 

It can be built with CMake, and it does have rudimentary tests to check for failures.
\end{block}
\pause
\begin{block}{C++ references}
Available online:
\begin{itemize}
\item \url{http://www.cplusplus.com/files/tutorial.pdf} \\ (brief tutorial)
\item \url{http://www.mindview.net/Books/DownloadSites} \\ Thinking in C++ (complete book)
\end{itemize}
\end{block}

\end{frame}

\subsection{Encapsulation}

\begin{frame}
\frametitle{Encapsulation}
\framesubtitle{Keep related concepts together}

\begin{block}{Example: the Animal class}
It may have:
\begin{itemize}
\item Fields like race, gender, color, etc.
\item A method for printing how an animal feels towards another animal
\end{itemize}
\end{block}
\pause
\begin{block}{Then we can create Animal objects and use them}
Compare this with having ordered arrays for each field, and an external method that takes two Animal objects and returns the result.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Encapsulation}
\framesubtitle{Show only what is necessary}

\begin{block}{Private versus public}
Methods and fields that do not need to be freely accessed should be set private:
\begin{itemize}
\item Fields should be made private when they cannot be set after creation; we can still provide a method to get the value
\item Methods should be made private when they are used internally, and external use may compromise the state of the object
\end{itemize}
\end{block}
\pause
\begin{itemize}
\item C structs are similar to very simple classes with public access and no methods or operators
\end{itemize}

\end{frame}

\subsection{Inheritance}

\begin{frame}
\frametitle{Inheritance}
\framesubtitle{Create classes that extend a base/parent class}

\begin{block}{Subclasses inherit the behavior}
They see everything of the base class if set as public, and also everything set as {\em protected}. Protected fields and methods are private to the rest of the world.
\end{block}
\pause
\begin{block}{Subclasses can override a method, if set as {\em virtual} on the base class}
In this way, you can provide a generic implementation and rewrite it for specific cases.
\end{block}
\end{frame}

\subsection{Polymorphism}

\begin{frame}
\frametitle{Polymorphism}
\framesubtitle{Deal with superclass variables}

\begin{block}{How do we exploit the \texttt{Dog} and \texttt{Cat} classes in the test?}
The trick: we can assign an object of a class to a variable of its parent class.
\end{block}
\pause
\begin{block}{The implementation of \texttt{feelsAbout} is decided at runtime based on the actual object on which it is called}
In this way, you can ignore the details of the implementation and focus on the available methods.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Polymorphism}
\framesubtitle{Abstract classes and interfaces}

\begin{block}{Probably a "concrete" \texttt{Animal} class is not that useful}
We can create an {\em abstract} class by making at least one method {\em pure virtual}.
\begin{itemize}
\item Pure virtual methods do not need to be defined
\item Objects of abstract classes cannot be created
\end{itemize}
\end{block}
\pause
\begin{block}{An interfaces is an abstract class with all pure virtual methods}
Nothing of its behavior is defined: only the {\em signatures} of its methods.
\end{block}

\end{frame}

\section{Tutorial}

\subsection{Object creation}

\begin{frame}
\frametitle{Object creation}
\framesubtitle{Constructors and destructor}

\begin{block}{A constructor is called to configure an object}
\begin{itemize}
\item It has the name of the class and doesn't have a return type
\item It sets up an object using one or more arguments
\item Multiple constructors can be defined
\end{itemize}
\end{block}
\pause
\begin{block}{A destructor is used to clean up resources}
\begin{itemize}
\item It has the name of the class with a tilde prefix, and doesn't have arguments or a return type
\item Only one destructor can exist
\item It needs to be explicitly defined only if dynamic memory is allocated for the object fields
\end{itemize}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Object creation}
\framesubtitle{Allocation: stack versus heap}

\begin{block}{Compare the following:}
\begin{itemize}
\item \texttt{Number num(1.0); }
\item \texttt{Number* num = new Number(1.0); }
\end{itemize}
Both call the same constructor, but
\begin{itemize}
\item The first object is allocated in the {\em stack}, hence the object is destroyed when the variable loses scope
\item The second object is allocated in the {\em heap} (and the pointer in the stack), hence the object is not destroyed
\end{itemize}
Similarly to C pointers, we can copy pointers that point to the same object in order to access an object in the heap.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Object creation}
\framesubtitle{Allocating an array}

\begin{block}{Same as before:}
\begin{itemize}
\item \texttt{Number nums[2]; }
\item \texttt{Number* num = new Number[2]; }
\end{itemize}
where you must consider that constructors are called. If no constructor with zero arguments exists, this does not even compile. In C++11, you can initialize with
any constructor by using:
\begin{itemize}
\item \texttt{Number nums[2] \{ Number(1.0), Number(2.0) \}; }
\item \texttt{Number* num = new Number[2] \{ Number(1.0), Number(2.0) \}; }
\end{itemize}
Note: prefer \texttt{std::array} objects to the plain array: more flexible.
\end{block}

\end{frame}

\begin{frame}
\frametitle{Object creation}
\framesubtitle{Cleaning up}

\begin{block}{Stack allocation should be preferred}
The destructor is called automatically, so there is little ground for errors. We only need to be clear about the lifetime of the object.
\end{block}
\pause
\begin{block}{When heap allocation is necessary, clean up with {\em delete}}
\begin{itemize}
\item \texttt{delete variableName;} \,\,\, if it is a single variable
\item \texttt{delete[] variableName;} \,\,\, if it is an array
\end{itemize}
This applies to non-class types too.
\end{block}
\end{frame}
